
# -----------------------------------------------------------------------------
# ğŸŒŸ Beginner-Friendly Explanation: Why Each Roboshop Component Connects as It Does ğŸŒŸ
# -----------------------------------------------------------------------------
# 1ï¸âƒ£ Frontend
#    ğŸ–¥ï¸ - The frontend is the user interface (website) that customers use to shop.
#    ğŸ“¡ - It does not store any business data itself. Instead, it sends API requests to backend services to get or update information.
#    ğŸ›’ - Example: When a user clicks "Add to Cart," the frontend calls the Cart Service API.
#    ğŸ¯ - Purpose: To provide a user-friendly interface and delegate all business logic to backend services.
#
# 2ï¸âƒ£ Cart Service
#    ğŸ›ï¸ - Manages the user's shopping cart (what items are added, removed, etc.).
#    ğŸ”— - Connects to Redis:
#        âš¡ Purpose: To store cart data and user sessions quickly and temporarily. Redis is fast and ideal for this use-case.
#    ğŸ”— - Connects to Catalogue Service:
#        ğŸ—‚ï¸ Purpose: To fetch product details (name, price, etc.) when a user adds an item to the cart. The cart service does not store product info itself.
#    ğŸ› ï¸ - How: Uses the CATALOGUE_HOST and REDIS_HOST variables, set by Ansible, to know where to connect.
#
# 3ï¸âƒ£ Catalogue Service
#    ğŸ“¦ - Stores and manages all product information (name, price, description, etc.).
#    ğŸ”— - Connects to MongoDB:
#        ğŸ“ Purpose: To store flexible, document-based product data. MongoDB is good for catalogs that may change structure over time.
#    ğŸ› ï¸ - How: Uses the MONGODB_HOST variable set by Ansible.
#    ğŸ”„ - Other services (like Cart and Frontend) connect to the catalogue to get product details.
#
# 4ï¸âƒ£ User Service
#    ğŸ‘¤ - Manages user accounts, logins, and registration.
#    ğŸ”— - Connects to MongoDB:
#        ğŸ—ƒï¸ Purpose: To store user data flexibly and efficiently.
#    ğŸ› ï¸ - How: Uses the MONGODB_HOST variable set by Ansible.
#    ğŸ”„ - The frontend and other services connect to the user service to authenticate users or get user info.
#
# 5ï¸âƒ£ Shipping Service
#    ğŸšš - Handles shipping information and order delivery.
#    ğŸ”— - Connects to MySQL:
#        ğŸ—„ï¸ Purpose: To store structured, relational shipping and order data.
#    ğŸ› ï¸ - How: Uses the MYSQL_HOST variable set by Ansible.
#    ğŸ”„ - Other services connect to shipping to get delivery status or update shipping info.
#
# 6ï¸âƒ£ Payment Service
#    ğŸ’³ - Manages payment processing and order payments.
#    ğŸ”— - Connects to MySQL:
#        ğŸ’° Purpose: To store payment transactions and order payment status in a reliable, transactional database.
#    ğŸ› ï¸ - How: Uses the MYSQL_HOST variable set by Ansible.
#    ğŸ”„ - The frontend and other services connect to payment to process or check payments.
#
# 7ï¸âƒ£ Redis
#    ğŸ§  - An in-memory database used for fast, temporary storage (like shopping cart sessions).
#    ğŸ”— - Only the Cart Service connects to Redis in this architecture.
#    âš¡ Purpose: To provide quick access to session and cart data, improving user experience.
#
# 8ï¸âƒ£ MongoDB
#    ğŸ—„ï¸ - A NoSQL database used by Catalogue and User services for flexible, document-based storage.
#    ğŸ”— - Only Catalogue and User services connect to MongoDB.
#    ğŸ“ Purpose: To store data that may change structure over time (products, users).
#
# 9ï¸âƒ£ MySQL
#    ğŸ—ƒï¸ - A relational database used by Shipping and Payment services for structured, transactional data.
#    ğŸ”— - Only Shipping and Payment services connect to MySQL.
#    ğŸ¦ Purpose: To ensure data integrity and support complex queries for orders and payments.
#
# ğŸ”Ÿ RabbitMQ (if used)
#     ğŸ“¨ - A message broker for asynchronous communication between services (like order events, notifications).
#     ğŸ”— - All services can connect to RabbitMQ to send or receive messages.
#     ğŸ”„ Purpose: To decouple services and allow them to communicate reliably, even if one is temporarily down.
#
# -----------------------------------------------------------------------------
# â“ Why this design?
# - Each microservice is responsible for a specific business function and uses the best database for its needs. ğŸ†
# - Services are independent: you can scale, update, or fix one without affecting others. ğŸ”„
# - If any backend (like Redis, MongoDB, or MySQL) is down, the dependent service will not work correctly (e.g., Cart wonâ€™t work if Redis is down). ğŸš¨
# - All hostnames (like catalogue.srivenkata.shop) are set in each serviceâ€™s vars file and injected into systemd service files by Ansible for easy configuration. ğŸ› ï¸
# -----------------------------------------------------------------------------
# ğŸ” Example Flows: What Happens When You Click or Use Each Component
# -----------------------------------------------------------------------------
# 1ï¸âƒ£ Add to Cart (from Frontend)
#    ğŸ–±ï¸ - User clicks "Add to Cart" on the website (Frontend)
#    ğŸ“¡ - Frontend sends API request to Cart Service
#    ğŸ”„ - Cart Service:
#        a. Calls Catalogue Service to get product details (Catalogue fetches from MongoDB)
#        b. Stores cart/session data in Redis
#    ğŸ“¬ - Cart Service responds to Frontend
#    ğŸ–¥ï¸ - Frontend updates the UI
#
# 2ï¸âƒ£ View Product Details
#    ğŸ‘ï¸ - User clicks a product on the website
#    ğŸ“¡ - Frontend sends API request to Catalogue Service
#    ğŸ—‚ï¸ - Catalogue Service fetches product info from MongoDB
#    ğŸ“¬ - Catalogue Service responds to Frontend
#    ğŸ–¥ï¸ - Frontend displays product details
#
# 3ï¸âƒ£ User Login/Register
#    ğŸ“ - User submits login/register form on Frontend
#    ğŸ“¡ - Frontend sends API request to User Service
#    ğŸ—ƒï¸ - User Service fetches/updates user info in MongoDB
#    ğŸ“¬ - User Service responds to Frontend
#    ğŸ–¥ï¸ - Frontend updates UI (shows user logged in)
#
# 4ï¸âƒ£ Place Order (Checkout)
#    ğŸ›’ - User clicks "Checkout" on Frontend
#    ğŸ“¡ - Frontend sends API request to Cart Service
#    ğŸ§º - Cart Service fetches cart data from Redis
#    ğŸ”„ - Cart Service may call Catalogue Service for latest product info
#    ğŸšš - Cart Service sends order info to Shipping and Payment Services
#    ğŸ—„ï¸ - Shipping Service stores order/shipping info in MySQL
#    ğŸ’° - Payment Service processes payment and stores transaction in MySQL
#    ğŸ“¨ - All services may send/receive messages via RabbitMQ (if used)
#    ğŸ–¥ï¸ - Frontend updates UI with order status
#
# 5ï¸âƒ£ View Order Status
#    ğŸ‘ï¸ - User requests order status on Frontend
#    ğŸ“¡ - Frontend sends API request to Shipping Service
#    ğŸ—„ï¸ - Shipping Service fetches order info from MySQL
#    ğŸ“¬ - Shipping Service responds to Frontend
#    ğŸ–¥ï¸ - Frontend displays order status
# -----------------------------------------------------------------------------
# ğŸ“ This step-by-step flow shows how each component interacts for common user actions, making it easy for beginners to understand the full path of a request.
# -----------------------------------------------------------------------------


# -----------------------------------------------------------------------------
# ğŸ—ºï¸ Project Flow Summary (Beginner Notes)
# -----------------------------------------------------------------------------
# - Each microservice (cart, user, catalogue, shipping, payment, etc.) is set up as a separate role in Ansible. ğŸ› ï¸
# - Common tasks (like app setup, maven build, systemd setup) are placed in a 'common' role and included where needed. ğŸ”„
# - Variables (like hostnames, credentials) are defined in each role's vars directory for easy configuration. ğŸ—‚ï¸
# - Templates (like systemd service files) use these variables to generate correct configs for each service. ğŸ“
# - Handlers are used to restart services only when configuration changes. ğŸ”
# - The playbook (main.yaml) is generic and can deploy any component by passing the 'component' variable. ğŸ§©
# - The flow for each component: inventory â†’ playbook â†’ role tasks â†’ common tasks â†’ templates/vars â†’ handlers. ğŸ”„
# - This modular approach makes the project easy to maintain, scale, and troubleshoot. ğŸš€
# -----------------------------------------------------------------------------



[Frontend] ğŸ–¥ï¸
   |
   |---> [Cart Service] ğŸ›’ -----------+
   |                               |
   |---> [User Service] ğŸ‘¤          |
   |                               |
   |---> [Catalogue Service] ğŸ“¦     |
   |                               |
   |---> [Shipping Service] ğŸšš      |
   |                               |
   |---> [Payment Service] ğŸ’³       |
   |                               |
   |---> [Other APIs...]           |
                                   |
[Cart Service] ğŸ›’ ------------------+
   |                               |
   |---> [Redis] ğŸ§                  |
   |---> [Catalogue Service] ğŸ“¦ ----+
                                   |
[Catalogue Service] ğŸ“¦ -----------> [MongoDB] ğŸ—„ï¸
[User Service] ğŸ‘¤ ---------------> [MongoDB] ğŸ—„ï¸
[Shipping Service] ğŸšš -----------> [MySQL] ğŸ—ƒï¸
[Payment Service] ğŸ’³ ------------> [MySQL] ğŸ—ƒï¸
[Cart Service] ğŸ›’ ---------------> [Redis] ğŸ§ 
[All Services] -----------------> [RabbitMQ] ğŸ“¨ (if used for messaging)

ğŸ’¡ Explanation
Frontend talks to all backend services via API endpoints. ğŸŒ
Cart Service needs:
REDIS_HOST (for session storage) ğŸ§ 
CATALOGUE_HOST (to fetch product details) ğŸ“¦
Catalogue Service and User Service use MONGODB_HOST. ğŸ—„ï¸
Shipping and Payment use MYSQL_HOST. ğŸ—ƒï¸
RabbitMQ is used for messaging between services (if implemented). ğŸ“¨
All hostnames (like catalogue.srivenkata.shop) are set in each serviceâ€™s vars file and injected into systemd service files by Ansible. ğŸ› ï¸
















